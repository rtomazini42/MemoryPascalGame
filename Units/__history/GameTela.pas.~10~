unit GameTela;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,
  System.ImageList, FMX.ImgList, FMX.Controls.Presentation, FMX.StdCtrls,
  FMX.Objects, FMX.Layouts, System.Generics.Collections;


type
  TGameLoop = class(TForm)
    ImageList1: TImageList;
    Rectangle1: TRectangle;
    Label1: TLabel;
    Pontuacao: TLabel;
    Layout1: TLayout;
    Layout2: TLayout;
    Layout3: TLayout;
    Rectangle2: TRectangle;
    Voltar: TLabel;
    Image1: TImage;
    procedure FormCreate(Sender: TObject);
    procedure Image1Click(Sender: TObject);
    procedure Image2Click(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  GameLoop: TGameLoop;
  ParSelecionado: Boolean;

implementation

{$R *.fmx}

uses GameStatus;

procedure TGameLoop.FormCreate(Sender: TObject);
var
  i, j, temp, randomIndex, rowIndex, colIndex: Integer;
  img: TImage;
  numPares: Integer;
  tam: TSizeF;
  indices: array of Integer;
begin
  numPares := GameStatus.getNumPares;
  tam.cx := 64;
  tam.cy := 64;

  if numPares > ImageList1.Count - 1 then
    numPares := ImageList1.Count - 1;

  SetLength(indices, numPares * 2);
  for i := 0 to numPares * 2 - 1 do
    indices[i] := (i div 2) + 1; // Começa a partir do índice 1 para evitar o verso do card

  // Algoritmo de Fisher-Yates para embaralhar os índices
  for i := High(indices) downto 1 do
  begin
    randomIndex := Random(i + 1);
    temp := indices[i];
    indices[i] := indices[randomIndex];
    indices[randomIndex] := temp;
  end;

  rowIndex := 0;
  colIndex := 0;

  for i := 0 to High(indices) do
  begin
    img := TImage.Create(Layout2);
    img.Parent := Layout2;
    img.Width := 32;
    img.Height := 32;
    img.Position.X := colIndex * (img.Width + 10);
    img.Position.Y := rowIndex * (img.Height + 10);
    img.Bitmap.Assign(ImageList1.Bitmap(tam, 0)); // Inicialmente, mostre o verso do card
    img.TagString := indices[i].ToString; // O índice real da imagem é armazenado em TagString
    img.OnClick := Image1Click;

    Inc(colIndex);
    if colIndex >= 4 then
    begin
      colIndex := 0;
      Inc(rowIndex);
    end;
  end;

  ShowMessage(GameStatus.getNumPares.ToString);
end;




procedure TGameLoop.Image1Click(Sender: TObject);
var
  tam: TSizeF;
  imgIndex: Integer;
begin
  tam.cx := 64;
  tam.cy := 64;
  ParSelecionado := True;

  // Verifica se o Sender é realmente um TImage antes de fazer o typecast
  if Sender is TImage then
  begin
    imgIndex := StrToInt((Sender as TImage).TagString);

    (Sender as TImage).Bitmap.Assign(ImageList1.Bitmap(tam, imgIndex));
    (Sender as TImage).OnClick := Image2Click;
  end;
end;

procedure TGameLoop.Image2Click(Sender: TObject);
var
  tam: TSizeF;
  imgIndex: Integer;
begin
  ParSelecionado := False;
  tam.cx := 64;
  tam.cy := 64;

  // Verifica se o Sender é realmente um TImage antes de fazer o typecast
  if Sender is TImage then
  begin
    imgIndex := StrToInt((Sender as TImage).TagString);

    (Sender as TImage).Bitmap.Assign(ImageList1.Bitmap(tam, 0));
    (Sender as TImage).OnClick := Image1Click;
  end;
end;

end.
