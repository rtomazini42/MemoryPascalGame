unit GameTela;

interface

uses
  System.SysUtils, System.Types, System.UITypes, System.Classes, System.Variants,
  FMX.Types, FMX.Controls, FMX.Forms, FMX.Graphics, FMX.Dialogs,
  System.ImageList, FMX.ImgList, FMX.Controls.Presentation, FMX.StdCtrls,
  FMX.Objects, FMX.Layouts, System.Generics.Collections;


type
  TGameLoop = class(TForm)
    ImageList1: TImageList;
    Rectangle1: TRectangle;
    Label1: TLabel;
    Pontuacao: TLabel;
    Layout1: TLayout;
    Layout2: TLayout;
    Layout3: TLayout;
    Rectangle2: TRectangle;
    Voltar: TLabel;
    Image1: TImage;
    Timer1: TTimer;
    procedure FormCreate(Sender: TObject);
    procedure Image1Click(Sender: TObject);
    procedure Image2Click(Sender: TObject);
    procedure Timer1Timer(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  GameLoop: TGameLoop;
  ParSelecionado: Boolean;
  Par : Integer;
  tagStr: string;
  linha, coluna: string;
   FirstSelectedCard, SecondSelectedCard: TImage;

implementation

{$R *.fmx}

uses GameStatus;

procedure TGameLoop.FormCreate(Sender: TObject);
var
  i, j, temp, randomIndex, rowIndex, colIndex: Integer;
  img: TImage;
  numPares: Integer;
  tam: TSizeF;
  indices: array of Integer;
begin
  Timer1.Interval := 1000; // 1 segundo, ajuste conforme necessário
  Timer1.Enabled := False;
  Timer1.OnTimer := Timer1Timer;
  numPares := GameStatus.getNumPares;
  tam.cx := 64;
  tam.cy := 64;

  if numPares > ImageList1.Count - 1 then
    numPares := ImageList1.Count - 1;

  SetLength(indices, numPares * 2);
  for i := 0 to numPares * 2 - 1 do
    indices[i] := (i div 2) + 1; // Começa a partir do índice 1 para evitar o verso do card

  // Algoritmo de Fisher-Yates para embaralhar os índices
  for i := High(indices) downto 1 do
  begin
    randomIndex := Random(i + 1);
    temp := indices[i];
    indices[i] := indices[randomIndex];
    indices[randomIndex] := temp;
  end;

  rowIndex := 0;
  colIndex := 0;

  for i := 0 to High(indices) do
  begin
    img := TImage.Create(Layout2);
    img.Parent := Layout2;
    img.Width := 32;
    img.Height := 32;
    img.Position.X := colIndex * (img.Width + 10);
    img.Position.Y := rowIndex * (img.Height + 10);
    img.Bitmap.Assign(ImageList1.Bitmap(tam, 0)); // Inicialmente, mostre o verso do card
    img.TagString := 'l='+rowIndex.ToString+ 'c='+ colIndex.ToString + 'img'+indices[i].ToString; // O índice real da imagem é armazenado em TagString
    img.OnClick := Image1Click;

    Inc(colIndex);
    if colIndex >= 4 then
    begin
      colIndex := 0;
      Inc(rowIndex);
    end;
  end;
   //Par := -1;
  //ShowMessage(GameStatus.getNumPares.ToString);
end;




{procedure TGameLoop.Image1Click(Sender: TObject);
var
  tam: TSizeF;
  imgIndex: Integer;
begin
  tam.cx := 64;
  tam.cy := 64;


  // Verifica se o Sender é realmente um TImage antes de fazer o typecast
  if Sender is TImage then
  if ParSelecionado then
  begin
     if Par = StrToInt((Sender as TImage).TagString) then
        Pontuacao.Text :=   (Pontuacao.Text.ToInteger + 1).ToString
     else
     begin
      (Sender as TImage).Bitmap.Assign(ImageList1.Bitmap(tam, 0));
     end;
  end
  else
  begin
    imgIndex := StrToInt((Sender as TImage).TagString);

    (Sender as TImage).Bitmap.Assign(ImageList1.Bitmap(tam, imgIndex));
    (Sender as TImage).OnClick := Image2Click;
    Par :=  imgIndex;
    ParSelecionado := True;
  end;
end;             }


procedure TGameLoop.Image1Click(Sender: TObject);
var
  tam: TSizeF;
  imgIndex, posImg: Integer;
  strImgIndex: string;
begin
  tam.cx := 64;
  tam.cy := 64;

  if Sender is TImage then
    if ParSelecionado then
    begin
      posImg := Pos('img', (Sender as TImage).TagString);
      strImgIndex := Copy((Sender as TImage).TagString, posImg + 3, Length((Sender as TImage).TagString));

      if Par = StrToInt(strImgIndex) then
      begin
        Pontuacao.Text := (Pontuacao.Text.ToInteger + 1).ToString;
        ParSelecionado := False;
        FirstSelectedCard := nil; // Reset the first selected card
      end
      else
      begin
        // Mostrar a segunda carta brevemente
        (Sender as TImage).Bitmap.Assign(ImageList1.Bitmap(tam, StrToInt(strImgIndex)));
        SecondSelectedCard := Sender as TImage; // Set the second selected card
        tagStr := (Sender as TImage).TagString;
        Timer1.Enabled := True; // Ative o Timer para virar ambos os cards após o intervalo
      end;
    end
    else
    begin
      posImg := Pos('img', (Sender as TImage).TagString);
      strImgIndex := Copy((Sender as TImage).TagString, posImg + 3, Length((Sender as TImage).TagString));
      imgIndex := StrToInt(strImgIndex);

      (Sender as TImage).Bitmap.Assign(ImageList1.Bitmap(tam, imgIndex));
      (Sender as TImage).OnClick := Image2Click;
      Par := imgIndex;
      ParSelecionado := True;
      FirstSelectedCard := Sender as TImage; // Store the first selected card
    end;
end;

procedure TGameLoop.Image2Click(Sender: TObject);
var
  tam: TSizeF;
  imgIndex, p1, p2, p3: Integer;
  //tagStr, linha, coluna: string;
begin
  ParSelecionado := False;
  tam.cx := 64;
  tam.cy := 64;

  if Sender is TImage then
  begin
    tagStr := (Sender as TImage).TagString;

    // Para a linha
    p1 := Pos('l=', tagStr) + 2;
    p2 := Pos('c=', tagStr) - p1;
    linha := Copy(tagStr, p1, p2);

    // Para a coluna
    p1 := Pos('c=', tagStr) + 2;
    p3 := Pos('img', tagStr) - p1;
    coluna := Copy(tagStr, p1, p3);

    // Para o índice da imagem
    imgIndex := StrToInt(Copy(tagStr, Pos('img', tagStr) + 3, Length(tagStr)));

    (Sender as TImage).Bitmap.Assign(ImageList1.Bitmap(tam, 0));
    (Sender as TImage).OnClick := Image1Click;
    Par := -1;
  end;
end;


procedure TGameLoop.Timer1Timer(Sender: TObject);
var
  tam: TSizeF;
begin
  Timer1.Enabled := False; // Desative o Timer

  tam.cx := 64;
  tam.cy := 64;

  // Vire ambos os cards
  if Assigned(FirstSelectedCard) then
    FirstSelectedCard.Bitmap.Assign(ImageList1.Bitmap(tam, 0));
  FirstSelectedCard.OnClick := Image1Click;

  Par := -1;
  ParSelecionado := False;
  FirstSelectedCard := nil;
end;

end.
